# Reading Report on SSA

本报告主要讨论 SSA 形式下 SSAPRE 和 Value Numbering 这两种常见的公共子表达式消除算法，主要参考了以下论文

* [Partial redundancy elimination in SSA form](https://dl.acm.org/doi/abs/10.1145/319301.319348)
* [Value Numbering](https://onlinelibrary.wiley.com/doi/abs/10.1002/(SICI)1097-024X(199706)27:6%3C701::AID-SPE104%3E3.0.CO;2-0)

## SSAPRE

SSAPRE 算法的观察是，SSA 形式本质上是为每个变量构建了 factored def-use graph，在这样一种稀疏的表示中，算法需要计算的信息能够更快地进行传播。而冗余的表达式的消除其实也是使用 def-use 链。表达式的首次计算对应 def，在表达式的值被 kill 掉前的再次计算就对应 use。因此，如果我们为每个需要消除冗余的表达式构造相应的 factored def-use graph（在论文中称为 FRG，Factored Redundancy Graph），图上的 def 节点该表达式的首次计算，需要将结果存入临时变量中。原程序在 use 节点的计算则替换为该临时变量，图上的汇聚节点则表示需要在源程序中插入新的 phi 函数。这样算法优化后的程序天然地是 SSA 形式的。

但 SSAPRE 是一个根据根据字面变量判断表达式是否冗余的算法（lexically equivalent），这导致它与 SSA 形式又有些不搭，因为 SSA 重命名后，例如原来在一条流图路径上出现两次的`a+b`表达式可能被替换为替换为 `a1 + b1` 和 `a2 + b1` ，许多字面上冗余的表达式便消失了。出于此，SSAPRE 算法对输入的 SSA 形式做了极强的假定：

* 每个 phi 函数的操作数和值都对应源程序的同一个变量
* 对应源程序中同一个变量的这些变量的存活期（live range）互不重叠

这样，SSAPRE 在判断两个表达式是否相同时，如果两个操作数对应源程序的同一个变量，那么就认为这两操作数相同。因此 SSAPRE 在冗余消除时认为上面的 `a1 + b1` 与 `a2 + b1` 是同一个表达式，因此 SSAPRE 与经典的 PRE 算法的冗余消除对象是完全一致的。但这也体现出 SSAPRE 的一个别扭的地方，即 SSAPRE 本质上并没有将输入程序视为单赋值的 SSA 形式，它只是将原来的 PRE 算法中使用的数据流分析替换为基于 FRG 的稀疏数据流分析，然后顺势利用 FRG 的 def-use 关系将结果转化为 SSA 形式，这也是为什么论文中假定了输入的 SSA 形式与源程序极强的对应关系。对于 LLVM 这样的 IR 已经是 SSA 形式的编译框架，使用 SSAPRE 会存在一定的困难。

然后简单说一下 SSAPRE 算法的步骤。根据论文中的描述，针对要优化冗余的表达式 E，SSAPRE 的算法步骤大致可以分为以下几步

* 每处 E 出现的位置的控制边界插入 PHI 函数，同时在每处 E 中包含变量的 phi 节点处插入 PHI 函数，保证程序的每个位置都只有一个可能的 E 的值。然后通过重命名构建 FRG，FRG 的节点就是所有的 PHI 函数以及输入程序中计算 E 的语句。节点之间的边便是 def-use 关系。如果一个 PHI 函数的某个操作数在源程序中还没有计算过（或者说是计算过又被变量的赋值给 kill 掉了），该操作数用 \_|\_ 替代，表明该操作数的路径上表达式 E unavailable。
* 接下来是利用 FRG 图计算 PHI 函数的 DownSafety 属性，该属性为真表明该 PHI 函数所在的位置是否预期执行 E。
* 进一步计算每个 PHI 函数的 can_be_avail 属性，该属性表明是否可以在程序中插入预期执行的 E，使得在 PHI 函数的位置表达式 E 完全可获得（fully avaliable）。然后在此基础上计算 PHI 函数的 will_be_avail 属性，它为真时表明了在任何最佳放置策略下（computationally optimal placement）都能保证在 PHI 函数的位置表达式 E  fully available。如果一个 PHI 函数 can_be_avail 属性为真，而 will_be_avail 属性不为真，说明在该 PHI 函数的位置插入的表达式 E 是可后延的（postponable）。实际上，算法最后所有 will_be_avail 属性为真的 PHI 函数在算法最后会变为源程序的 phi 函数（在交界点汇集多个 E 的值），而 will_be_avail 属性为假的 PHI 函数则会被删除。
* 最后算法执行表达式 E 的插入。如果我们在插入点 I 插入了 E 的计算，那么 I 的后继基本块有一个 PHI 函数，该 PHI 函数的对应 I 的 基本块的操作数 o，则要么 o 是 \_|\_，或者在 FRG 上定义 o 的节点是一个 will_be_avail 为 false 的 PHI 函数、且 源程序中该 PHI 到 I 的路径上没有出现表达式 E 的计算（因为在最佳放置策略下 will_be_avail 为 false 的 PHI 函数的位置 E 是 unavailable 的，而从这个 PHI 到 I 的路径上又没有 E 的计算，因此也就相当于 o 是 \_|\_ 的情况了）。
* 插入完成后，算法删除多余的 PHI 函数。这里多余的 PHI 函数分两类，一类是 will_be_avail 为 false 的 PHI 函数，另一类是 will_be_avail 为 true，但是所有操作数的值都相同。然后算法通过先序遍历支配树，将 def 处的 E 的值存入临时变量，在 use 处 E 的计算用临时变量的值替代，剩下的没有被删除的 PHI 函数变为普通的 phi 函数，用来交汇临时变量的值。算法结束。

## Value Numbering

相比于 PRE，Value Numbering 更加简单自然，符合 SSA 形式的特点，且能够应用基本的代数变换，扩大冗余消除的范围，但是 Value Numbering 对部分冗余优化得不是很好。

在 [Value Numbering](https://onlinelibrary.wiley.com/doi/abs/10.1002/(SICI)1097-024X(199706)27:6%3C701::AID-SPE104%3E3.0.CO;2-0) 的论文中，主要讨论了两种 Value Numbering 的算法，一种是基于哈希的，对每个变量和表达式进行编号并加入哈希表中。如果一个表达式已经在哈希表中，那么就给予它与在哈希表中的表达式相同的编号。相同编号的表达式就是冗余消除的对象。另外一种基于分区（partition）的算法，通过反复迭代将各个变量划分为等价类，保证算法结束后在同一个等价类中的变量的值一定是相同的。

基于哈希的算法实现起来比较简单，论文中给出的算法步骤大概是：

* 先序遍历支配树，维护一个哈希表 `H`，它的键是算数表达式，值是存储该算数表达式结果的变量。
* 在每个遍历的基本块中，对每个形如 `x = y op z` 的表达式，如果可能，对表达式进行合适的变形或者化简（因此可以适用强度消减，常量传播等技巧），然后在哈希表中查找 `<op, y, z>` 这个表达式是否已经出现过了，如果是，则删除该语句，将每个出现 `x` 的地方用键 `<op, y, z>` 的值替换。如果没有找到，则将 `<op, y, z>` 作为键，`x` 作为值加入哈希表。
* 搜索到叶节点进行回退时，每回退一个基本块，需要将在该基本块内加入的哈希表项从哈希表中弹出。

基于分区的算法则是希望通过迭代划分出变量的等价类：如果两个变量，定义它们的运算符相同，且运算符的每个操作数都属于同一等价类，算法就认为这两个变量等价。论文中给出的算法步骤大概是：

* 算法首先乐观地将所有运算符相同的变量都划分到同一等价类，例如有 `x1 = y1 + z1`，`x2 = y2 + z2` 两条语句，由于变量 `x1, x2` 都使用加法定义，因此它们会被分到同一等价类。
* 算法将所有初始等价类加入到一个工作集中，然后进行循环迭代，直到工作集变空为止。
* 在每次迭代中，从工作集中随机选出一个等价类 `c`，并将其从工作集中删除。然后利用等价类 `c` 来寻找对等价类进一步划分的依据。具体来说，如果一个等价类 `d` 中存在两个变量 `A`，`B`，且存在整数 k，使得定义 `A`，`B` 的运算符的第 k 个操作数一个属于等价类 `c`，一个不属于，那么我们可以保守地认为变量 `A`，`B` 应该属于不同等价类。据此可以将等价类 `d` 一分为二。其它等价类也是同理，算法将新的等价类重新加入到工作集中。
* 直到工作集为空，我们可以认为现在在同一个工作集中的变量的值是相等的。等价类中的变量对应冗余，可以将多余的变量删除替代。

本质上来讲，基于哈希的算法其实悲观地（pessimistic）寻找等价类，而基于划分等价类的方法是乐观地寻找等价类（optimistic），后者能更好地发现循环中的等价类，但有着更高的时间复杂度。



以上是我在 SSA 部分的阅读报告。

