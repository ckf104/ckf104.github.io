# Reading Report on GC

本报告的内容主要分为两部分，第一部分叙述常见的 GC 算法，第二部分叙述这些 GC 算法在现在的编程语言中的应用，主要涉及到的编程语言是 python 和 go。撰写本次报告参考了以下材料

* [Uniprocessor garbage collection techniques](https://link.springer.com/chapter/10.1007/BFb0017182)

* [Design and implementation of a comprehensive real-time java virtual machine](https://dl.acm.org/doi/abs/10.1145/1289927.1289967)

* [Python garbage collector design](https://devguide.python.org/internals/garbage-collector/)
* [Go语言GC实现原理及源码分析](https://www.cnblogs.com/luozhiyun/p/14564903.html)
* [Proposal: Eliminate STW stack re-scanning](https://go.googlesource.com/proposal/+/master/design/17503-eliminate-rescan.md)

## 1. GC 相关概念与常见的 GC 算法

在 [Uniprocessor garbage collection techniques](https://link.springer.com/chapter/10.1007/BFb0017182) 这篇综述中回顾了 GC 相关的概念与常见算法，包括引用计数算法、标记清理算法（mark-sweep）、标记压缩算法（mark-compact）、基于复制的垃圾回收算法（copy garbage collection）、隐式的回收算法（non-copying implicit collection）。我们对这些算法具有的性质的角度进行分类和讨论。

### Tracing or Non-Tracing

非追踪形式的算法的典型代表是引用计数：记录指向某块已分配内存的指针数目，在指针数目归零时将已分配内存回收。但引用计数算法的问题在于它无法处理循环引用，当一块已分配内存上存在指向自己的指针时，引用计数算法无法将其回收。

上面列举的算法中，除了引用计数外，其它算法都是追踪形式的，能够处理循环引用问题。这类算法的普遍思路是，在算法运行时，构建一张图，图的节点是程序中的数据对象，边是数据的指针指向关系。定义图的根节点为：栈上的数据对象和全局的数据对象。如果所有根节点都不可达某个数据对象，那么该对象占用的内存就可以回收。

### Moving or Non-Moving

另外一个区分不同 GC 算法的重要特征是该算法是否会移动数据对象。在上面四种追踪算法中，标记压缩算法与基于复制的垃圾回收算法会移动数据对象，而标记清理算法与隐式的回收算法则不会。

内存分配中一个重要的难题在于如何解决内存碎片问题。标记压缩算法与基于复制的垃圾回收算法在垃圾回收时，会将所有存活的对象复制到连续的内存区域，以此来解决内存碎片，也有利于内存的局部性。但这却会带来内存复制、需要修改指针等额外的开销。

### Incremental / Concurrent GC

追踪形式的垃圾回收算法普遍需要在运行时暂停所有线程（Stop the World，下称 STW），以保证构建的指针指向图的正确性。但这对于有实时要求的程序很不友好，因此降低 GC 算法的 STW 时间至关重要。

递增式（Incremental）/ 并行式（Concurrent）GC 能够大幅降低算法的 STW 时间。通常我们称一个 GC 算法是递增的，如果它的算法流程不会在一次运行完成，而是每次运行一部分。而称 GC 算法是并行的，如果该 GC 算法与通常的应用程序并行运行。虽然两种定义有些许的差别，但基本的实现思想是一致的，即通过读写屏障（read/write barrier）来避免应用程序破坏构建的指针指向图。

通过这类 GC 算法的实现方法是三色标记，应用程序的数据对象有白色，黑色，灰色三种可能的颜色。在算法运行开始阶段，所有的数据对象都是白色。算法首先将根数据对象染为灰色，每当算法扫描完一个灰色对象时，该灰色对象染为黑色，然后将该对象所有指针指向的对象染为灰色。直到图上不再存在灰色对象，算法运行结束。所有白色对象占用的内存可以进行回收。因为算法不会访问已被染为黑色的对象，因此如果在算法运行时一个应用程序修改黑色对象 B 的指针指向一个白色对象 W，然后修改其它指针，使得仅有 B 指向 W，这会导致 GC 算法不可达 W，最终错误地回收了 W 的内存。

为解决这个问题，算法引入了读写屏障。即当应用程序读写指针时，GC 算法能够进行一些额外的操作。典型的写屏障有两种，一种是 Yuasa's write barrier，在应用程序写指针时，将原来指针指向的对象染为灰色。另外一种是  Dijkstra's write barrier，当应用程序写指针时，将新指针指向的对象染为灰色。不难验证这两种方法都可以保证 GC 算法的正确性。但对于需要移动对象的 GC 算法，需要代价更高的读屏障。这是因为 GC 算法移动对象时，并不能马上找到所有指向该对象的指针，因此应用程序可能使用未更新的指针读取到老的对象。通过读屏障，当应用程序获取该指针时，GC 算法检查该对象是否已经被移动了，如果是，将指针更新。读写屏障的实现通常需要编译器的参与，在指针读写的代码附近插入额外的检查等等。

### Generational GC

写屏障的另一个用武之地在于实现分代 GC 算法。分代 GC 的重要观察在于，许多对象的生命周期很短，而一些对象的生命周期很长，通过启发式的算法将数据对象分为若干代，分别进行垃圾回收，能够有效减少垃圾回收时需要访问的对象数目。通常的做法是，如果一个对象在针对第 K 代的垃圾回收算法中存活了若干次，那么将该对象放置在第 K+1 代中。针对越高代的对象的垃圾回收频率越低。

为了有效地仅针对第 K 代的对象进行垃圾回收，就有必要快速找到所有的其它代指向该代对象的指针（Intergenerational References），以保证搜索时仅需要访问第 K 代的对象。这便是写屏障的用武之地了，每次指针的写操作时，判断新指针是否是跨代指针，如果是则记录下来。

## 2. GC 算法在常见编程语言中的应用

### python

python 中混合使用了两种 GC 算法，一种是基本的引用计数，另一种是分代的隐式回收算法（generational non-copying implicit collection），python 中将对象分为了三代，同一代的对象使用链表连接。有意思的地方在于 python 如何找到跨代指针，python 并没有采用写屏障的方式。在垃圾回收时，python 首先会遍历一遍该代的对象，统计它们被本代对象引用的次数，如果不等于该对象的引用计数，那说明该对象被其它代的对象或者外部的指针引用了。这样的对象重新作为搜索的根对象，从这些根对象出发，不可达的对象就可以进行垃圾回收。

### go

go 语言的垃圾回收算法则更具有代表性。原因是 python 作为一门脚本语言，解释器拥有对代码运行的完全控制，因此能够轻易解决寻找指针指向图的根对象、判断数据是否为指针这两个实现垃圾回收所面临的最基本问题。但 go 语言会编译为二进制，通过考察垃圾回收系统如何解决这两个问题，能够看到编译器和运行时库的协作。

首先是判断数据是否为指针，go 的编译器会在编译时保留类型信息，因此每一种类型的哪些字段为指针等信息会保留在二进制文件中。这使得堆管理系统能够维护一个位图，判断分配出去的堆内存中哪些位置包含指针。而根对象也是可以静态判断的，每一个函数的栈帧多大，栈帧中哪些位置是指针数据类型，全局数据中哪些位置是指针类型，这些信息在编译和链接时都通过位图保存起来了。

go 的 GC 算法运行时，通过扫描协程的栈帧以及二进制文件的 bss 和 data 段，结合位图，就能找到所有的根对象。而堆上的指针则通过堆管理系统维护的位图识别，由此能够建立起指针指向图进行垃圾回收。

另外，从算法的特点上看，go 的 GC 算法是并行的标记清理算法（concurrent mark-sweep algorithm）。既然是并行的，那一定离不开读写屏障。在 go 语言中，编译器会插入写屏障，即将指针的写操作`*ptr = val`改为下面的形式

```go
if writeBarrier.enabled {
   gcWriteBarrier(ptr, val)
} else {
   *ptr = val
}
```

其中`writeBarrier.enabled`是一个由 GC 系统控制的全局变量。当 GC 系统还未开始垃圾回收时，写屏障的代价是一次条件判断。而当 GC 系统开始垃圾回收后，将`writeBarrier.enabled`置1，此时指针写操作将陷入`gcWriteBarrier`调用中。

另外，为了进一步降低写屏障的开销，如果编译器能够静态分析出被写的指针是一个栈上的指针，那么将不会插入写屏障。因此仅有全局对象的指针和堆上对象的指针被写且 GC 算法开始运行时，才会陷入`gcWriteBarrier`调用。但这也给 go 的写屏障实现带来了额外的复杂度。由于栈上指针没有写屏障，仅有 Yuasa 或 Dijkstra 写屏障将不再奏效。事实上，go 语言采用了论文 [Design and implementation of a comprehensive real-time java virtual machine](https://dl.acm.org/doi/abs/10.1145/1289927.1289967) 中使用的混合写屏障

```go
writePointer(slot, ptr):
    shade(*slot)   // Yuasa's write barrier
    if current stack has not been scanned:
        shade(ptr)   // Dijkstra's write barrier
    *slot = ptr
```

该算法能奏效是因为，语言层面能保证一个协程要读到另一个协程的对象时，一定需要通过对堆对象或者全局对象的写来传递数据。



以上是我在 GC 算法相关的阅读报告。